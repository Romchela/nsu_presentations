<font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Сжатие данных </font> <img src="http://mephisto.ccfit.nsu.ru/~mahina/images/1.jpg" width=200 height=333 align="left" vspace="15" hspace="30"> </p>
    <p> <font style="text-decoration:underline;"> Сжатие данных</font> - алгоритмическое преобразование данных, производимое с целью уменьшения занимаемого ими объёма. Синонимы к этому понятию - упаковка данных, компрессия, сжимающее кодирование, кодирование источника. Обратная процедура называется восстановлением данных, или их распаковкой, декомпрессией. </p>
    <p> Существует много практических алгоритмов сжатия данных, но все они базируются на трех теоретических способах уменьшения избыточности данных. Первый способ состоит в изменении содержимого данных, второй - в изменении структуры данных, а третий - в одновременном изменении как структуры, так и содержимого данных. </p>
    <p> Если при сжатии данных происходит изменение их содержимого, то метод сжатия называется <font style="text-decoration:underline;">необратимым</font>, то есть при восстановлении (разархивировании) данных из архива не происходит полное восстановление информации. Такие методы часто называются методами сжатия с регулированными потерями информации. Понятно, что эти методы можно применять только для таких типов данных, для которых потеря части содержимого не приводит к существенному искажению информации. К таким типам данных относятся видео- и аудиоданные, а также графические данные. Методы сжатия с регулированными потерями информации обеспечивают значительно большую степень сжатия, но их нельзя применять к текстовым данным. </p> 
    <p> Примерами форматов сжатия с потерями информации могут быть:
	  <ul>
	    <li> JPEG - для графических данных
		<li> MPG - для для видеоданных
		<li> MP3 - для аудиоданных
	  </ul>
	 </p>
	 <p> Если при сжатии данных происходит только изменение структуры данных, то метод сжатия называется обратимым. В этом случае, из архива можно восстановить информацию полностью. Обратимые методы сжатия можно применять к любым типам данных, но они дают меньшую степень сжатия по сравнению с необратимыми методами сжатия. Примеры форматов сжатия без потери информации:
	   <ul>
	     <li> GIF, TIFF - для графических данных
		 <li> AVI - для видеоданных
		 <li> ZIP, ARJ, RAR, CAB, LH - для произвольных типов данных
    </p>
	<p> <font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Методы сжатия данных </font> </p>
	<p> Существует много разных практических методов сжатия без потери информации, которые, как правило, имеют разную эффективность для разных типов данных и разных объемов. Однако, в основе этих методов лежат три теоретических алгоритма:
	   <ol>
	     <li> алгоритм RLE (Run Length Encoding)
		 <li> алгоритмы группы KWE (KeyWord Encoding)
		 <li> алгоритм Хаффмана
	   </ol>
	</p>
    <p> <font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Алгоритм RLE </font> </p>
    <p> В основе алгоритма RLE лежит идея выявления повторяющихся последовательностей данных и замены их более простой структурой, в которой указывается код данных и коэффициент повторения. Например, пусть задана такая последовательность данных, что подлежит сжатию:
     <br> AAABBCCCCDEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	 <br> В алгоритме RLE предлагается заменить ее следующей структурой: 3A2B4C1D6E38A, где первый символ каждой пары - это код данных, а второй - коэффициент повторения. Если для хранения каждого элемента данных входной последовательности отводится 1 байт, то вся последовательность будет занимать 10 байт памяти, тогда как выходная последовательность (сжатый вариант) будет занимать 8 байт памяти. Коэффициент сжатия, характеризующий степень сжатия, можно вычислить по формуле:
	 <img src="http://mephisto.ccfit.nsu.ru/~mahina/images/2.png" width=60 height=45 align="center" vspace="5" hspace="10">, где k - коэффициент сжатия, So - объём исходных данных, а Sc - объём сжатых.
	</p>
    <p> <font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Алгоритмы группы KWE </font> </p>
	<p> В основе алгоритма сжатия по ключевым словам положен принцип кодирования лексических единиц группами байт фиксированной длины. Примером лексической единицы может быть обычное слово. На практике, на роль лексических единиц выбираются повторяющиеся последовательности символов, которые кодируются цепочкой символов (кодом) меньшей длины. Результат кодирования помещается в таблице, образовывая так называемый словарь. <img src="http://mephisto.ccfit.nsu.ru/~mahina/images/3.jpg" width=210 height=230 align="right" vspace="5" hspace="10"> </p>
	<p> <font style="text-decoration:underline;">Словарь</font> - это результат кодирования, помещенный в таблицу. </p>
	<p> Существует довольно много реализаций этого алгоритма, среди которых наиболее распространенными являются алгоритм Лемпеля-Зива (алгоритм LZ) и его модификация алгоритм Лемпеля-Зива-Велча (алгоритм LZW). </p>
	<p> <font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Алгоритм Лемпеля-Зива LZ77 </font> </p>
	<p> Словарем в данном алгоритме является потенциально бесконечный список фраз. Алгоритм начинает работу с почти пустым словарем, который содержит только одну закодированную строку, так называемая NULL-строка. При считывании очередного символа входной последовательности данных, он прибавляется к текущей строке. Процесс продолжается до тех пор, пока текущая строка соответствует какой-нибудь фразе из словаря. Но рано или поздно текущая строка перестает соответствовать какой-нибудь фразе словаря. В момент, когда текущая строка представляет собой последнее совпадение со словарем плюс только что прочитанный символ сообщения, кодер выдает код, который состоит из индекса совпадения и следующего за ним символа, который нарушил совпадение строк. Новая фраза, состоящая из индекса совпадения и следующего за ним символа, прибавляется в словарь. В следующий раз, если эта фраза появится в сообщении, она может быть использована для построения более длинной фразы, что повышает меру сжатия информации.</p>
	<p> <font align=center size=4.1 face="Arial" style="margin:15; font-weight:550; text-decoration:underline;">Примеры алгоритма LZ77</font>
	<p> 1. <br> <img src="http://mephisto.ccfit.nsu.ru/~mahina/images/4.jpg" width=420 height=230 align="left" vspace="5" hspace="10"> </p>
	<p> <br clear="left"> 2. Исходная строка:  <br> <img src="http://mephisto.ccfit.nsu.ru/~mahina/images/5.png" width=900 height=100 align="center" vspace="5" hspace="10"> </p>
	<p> Пожалуй, единственным неясным моментом здесь будет последовательность <Hahahahaha!>, ведь цепочке символов <ahahaha> соответствует короткая цепочка <ah>. Но здесь нет ничего необычного, мы использовали кое-какой приём, позволяющий алгоритму иногда работать как описанный ранее RLE.
	<br> Дело в том, что при распаковке мы будем считывать из словаря указанное количество символов. А поскольку вся последовательность периодична, т.е. данные в ней повторяются с некоторым периодом, и символы первого периода будут находиться прямо перед позицией распаковки, то по ним мы можем воссоздать всю цепочку целиком, просто копируя символы предыдущего периода в следующий. </p>
	<br> <img src="http://mephisto.ccfit.nsu.ru/~mahina/images/6.png" width=500 height=300 align="center" vspace="5" hspace="10">
    <p> Теперь заменим найденные повторы на ссылки в словарь. Будем записывать ссылку в формате [P|L], где P - позиция первого вхождения цепочки в строке, L - её длина. </p>
    <br> <font size=4.1 style="font-style:italic; font-weight:300"> The compression and t[22|3]de[5|12]leave[16|3] i[8|7]. Hah[61|7]! </font>
    <p>Но не стоит забывать, что мы имеем дело со скользящим окном. Для большего понимания, чтобы ссылки не зависели от размера окна, заменим абсолютные позиции на разницу между ними и текущей позицией кодирования.</p>
	<br> <font size=4.1 style="font-style:italic; font-weight:300"> The compression and t[20|3]de[22|12]leave[28|3] i[42|7]. Hah[2|7]! </font>
    <p>Теперь нам достаточно отнять P от текущей позиции кодирования, чтобы получить абсолютную позицию в строке.</p>
    <p> Поскольку мы имеем дело с текстом, редко когда в нём будут встречаться особо длинные повторяющиеся последовательности. Так что выделим под их длину 4 бита - лимита на 15 символов вполне хватит. </p>
	<p> А вот от размера окна уже зависит, насколько глубоко мы будем искать одинаковые цепочки. Поскольку мы имеем дело с небольшими текстами, то в самый раз будет дополнить используемое нами количество бит до двух байт: будем адресовать ссылки в диапазоне из 4096 байт, используя для этого 12 бит. </p>
	<p> По опыту с RLE мы знаем, что не всякие значения могут быть использованы. Очевидно, что ссылка может иметь минимальное значение 1, поэтому, чтобы адресовать назад в диапазоне 1..4096, мы должны при кодировании отнимать от ссылки единицу, а при декодировании прибавлять обратно. То же самое с длинами последовательностей: вместо 0..15 будем использовать диапазон 2..17, поскольку с нулевыми длинами мы не работаем, а отдельные символы последовательностями не являются. </p>
	<p> Итак, представим закодированный текст с учётом всех поправок: </p>
	<br> <font size=4.1 style="font-style:italic; font-weight:300"> The compression and t[19|1]de[21|10]leave[27|1] i[41|5]. Hah[1|5]! </font>
	<p> <font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Алгоритм Хаффмана </font> </p>
	<p> В основе алгоритма Хаффмана лежит идея кодирования битовыми группами. Сначала проводится частотный анализ входной последовательности данных, то есть устанавливается частота вхождения каждого символа, встречащегося в ней. После этого, символы сортируются по уменьшению частоты вхождения.</p>
	<p>Основная идея состоит в следующем: чем чаще встречается символ, тем меньшим количеством бит он кодируется. Результат кодирования заносится в словарь, необходимый для декодирования. </p>
	<p> <font align=center size=5 face="Arial Black" style="margin:15; font-weight:750; font-style:oblique;"> Заключение </font> </p>
	<p> Итак, теперь вы можете сказать, что разбираетесь в методах сжатия информации. <a href="/~mahina/talk/presentation.pptx"> Здесь</a> вы можете скачать презентацию по данной теме. Успехов в написании своих архивирующих программ! </p>
	<img src="http://mephisto.ccfit.nsu.ru/~mahina/images/7.jpg" width=410 height=230 vspace="5" hspace="10">
